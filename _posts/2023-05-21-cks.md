---
title: "CKS(Certified Kubernetes Security Specialist) 공부"
date: 2023-05-21
last_modified_at: 2023-05-21
categories:
  - Kubernetes
tags:
  - Certification
---

CKS(Certified Kubernetes Security Specialist) 프로그램은 CKS가 빌드, 배포 및 런타임 중에 컨테이너 기반 애플리케이션 및 Kubernetes 플랫폼을 보호하기 위한 광범위한 모범 사례에 대한 기술, 지식 및 역량을 보유하고 있음을 보증합니다.이 시험에 응시하려면 CKA 인증이 필요합니다.
{: .notice}

- [Certified Kubernetes Security Specialist (CKS)](https://training.linuxfoundation.org/certification/certified-kubernetes-security-specialist/)

---

## 시험 환경
- 시험은 PSI 전용 프로그램안에서 실행한다.
- 전용 프로그램안에 원격 터미널로 시험환경에 접속하는데 리눅스 GUI환경에서 작업할 수 있다.
- 클립보드는 막혀있다.
- 시험환경에서는 한글지원이 안된다. 한글이 깨진다.
- 북마크는 따로 제공해 준다. 시험 키워드 글자를 누르면 시험환경의 파이어폭스 브라우저에서 페이지로 이동한다.
- 시험 시작하면 먼저 텍스트 문서를 하나 만든다음 시험 문제를 1번 부터 16번 까지 적어두고 문제를 풀었으면 표시를 해 두자! (시험 환경에서는 풀었는지 안풀었는지 구분할 수 없다.)
- 시험 시간이 2시간이지만 시간이 매우 부족하다.

---

## 시험 유형

1. kube-bench
2. ServiceAccount
3. NetworkPolicy
4. RBAC - RoleBinding
5. log audit
6. Secret
7. Dockefile
8. gVisor
9. Trivy
10. AppArmor
11. Sysdig & falco
12. Container Security Context
13. API Server
14. TLS
15. ImagePolicyWebhook

---

### 1. kube-bench

■ API 서버에서 발견된 다음 위반 사항을 모두 수정합니다.

- 1.2.7 Ensure that the --authorization-mode argument is not set to `AlwaysAllow`
- 1.2.8 Ensure that the --authorization-mode argument includes `Node`
- 1.2.9 Ensure that the --authorization-mode argument includes `RBAC`
​

```bash
# kube-apiserver.yaml 파일을 수정한다.
vi /etc/kubernetes/manifests/kube-apiserver.yaml

# 아래내용으로 수정한다.
  - --authorization-mode=Node,RBAC
```

■ kubelet에서 발견된 다음 위반 사항을 모두 수정합니다 .
- 4.2.1 Ensure that the anonymous-auth argument is set to `false`
- 4.2.2 Ensure that the anonymous-mode argument is not set to `AlwaysAllow`

```bash
# kubelet config.yaml 파일을 수정한다.
​vi /var/lib/kubelet/config.yaml

​# 아래 내용으로 수정한다.
authentication:
   anonymous:
     enabled: false   # false로 설정
   webhook:
     cacheTTL: 0s
     enabled: true    # true로 설정
authorization:
  mode: Webhook       # Webhook  설정
​
# 서비스 재시작을 해야한다.
systemctl daemon-reload
systemctl restart kubelet.service
```

■ etcd에 대해 발견된 다음 위반 사항을 모두 수정합니다.

- 2.2 Ensure that the --client-cert-auth argument is set to `true`

```bash
# etcd.yaml 파일을 편집한다.
vi /etc/kubernetes/manifests/etcd.yaml

​# 아래 내용으로 수정한다.
  - --client-cert-auth=true
```

---

### 2. ServiceAccount

보안 정책에는 다음이 포함됩니다.
- ServiceAccount는 <U>API 자격 증명을 자동으로 탑재해서는 안 됩니다.</U>
- ServiceAccount 이름은 `-sa`로 끝나야 합니다.

■ ServiceAccount 만들기

- `ServiceAccount`에 `automountServiceAccountToken: false` 설정을 한다.

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: backend-sa                    #해당 이름으로 변경
  namespace: qa                       #namespace 이름
automountServiceAccountToken: false   #false는 비밀을 자동으로 마운트하지 않음을 의미합니다.
```

■ Pod 만들기

- `Pod`에 `automountServiceAccountToken: false` 설정을 한다.

```yaml
metadata:
  name: backend
  namespace: qa                   # 네임스페이스가 올바른지 주의하십시오.
spec:
  serviceAccountName: backend-sa  # 이전만 생성한 ServiceAccount 이름 추가
```
​
■ 사용하지 않는 ServiceAccount 정리

- <u>문제에서는 사용하지 않는 SA를 정리하라고 출제된다!</u>

```bash
kubectl -n qa get sa
kubectl -n qa get pod -o yaml | grep -i serviceAccountName
kubectl -n qa delete sa test01
```
[참고] [Use the default service account to access the API server](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server)

---

### 3. NetworkPolicy

#### case 01  

`pod-restriction` 이라는 `NetworkPolicy`를 만들어 네임스페이스 `dev-team`에서 실행 중인 `products-service`에 대한 <U>액세스를 제한</U>합니다.

<U>다음 Pod만 products-service에 연결하도록 허용</U>
1. 네임스페이스 `qaqa`의 포드
2. 레이블이 `environment: testing`인 모든 네임스페이스의 포드

■ 네임스페이스 태그를 확인 합니다.

```bash
# namespace 확인
kubectl get ns --show-labels

# pod 확인
kubectl get pod -n dev-team --show-labels

# namespace 레이블이 없으면 설정합니다.
kubectl label ns qaqa name=qaqa

# pod 레이블이 없으면 설정합니다.
kubectl label pod products-service environment=testing -n dev-team
```

■ 네트워크폴리시정책을 설정하고 적용합니다.
- 기본 템플릿은 제공하기 때문에 조건에 맞게 문제만 풀이하면 됩니다.

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: pod-restriction          # 이름 조건
  namespace: dev-team            # 네임스페이스 조건
spec:
  podSelector:
  matchLabels:
    environment: testing         # label 조건
  policyTypes:
  - Ingress                      # 들어오는 검사
  ingress:
  - from:
    - namespaceSelector:
      matchLabels:
        name: qaqa               # 네임스페이스가 qaqa
  - from:
    - namespaceSelector: {}
      podSelector:
        matchLabels:
          environment: testing   # 모든 네임스페이스 허용하나 environment: testing 레이블이 붙어야 함
```

#### case 02  
- `Ingress + Egress` 유형의 모든 트래픽에 대한 네임스페이스 테스트 에서 이름이 `denypolicy`인 새 기본 거부 `NetworkPolicy`를 만듭니다.
- 이 새로운 `NetworkPolicy`는 네임스페이스 테스트 에서 모든 `Ingress + Egress` 트래픽을 `거부`해야 합니다. 
- 네임스페이스 `test` 에서 실행 중인 모든 포드에 새로 생성된 `Default Deny NetworkPolicy`를 적용합니다 .

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: denypolicy
  namespace: testing
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
```

[참고] [default-deny-all-ingress-and-all-egress-traffic](https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-deny-all-ingress-and-all-egress-traffic)
​
이렇게 하면 다른 `NetworkPolicy`에서 선택하지 않은 포드도 `Ingress` 또는 `Egress` 트래픽이 허용되지 않습니다.

---

### 4. RBAC - RoleBinding

■ 이름이 `web-pod` 인 기존 포드가 네임스페이스 `db` 에서 이미 실행 중입니다.
Pod의 ServiceAccount `service-account-web` 에 바인딩된 기존 역할을 편집하여 `services` 유형의 리소스에 대한 `가져오기` 작업 만 허용합니다.

```bash
# role-1 이름의 role을 수정합니다.
kubectl -n db edit role role-1
```

`role-1`이름의 role에서 아래와 같이 수정합니다.

```yaml
# resources와 verbs를 수정합니다.
rules:
- apiGroups:
  - ""
  resources:
  - services    # services에 대해
  verbs:
  - get         # get 작업 허용!
```

■ 네임스페이스 `db` 에 `role-2` 라는 새 역할을 만들고 `namespaces` 유형의 리소스에 대한 `삭제` 작업 만 허용합니다. 
새로 생성된 Role을 Pod의 ServiceAccount에 바인딩하기 위해 `role-2-binding` 이라는 새 RoleBinding을 생성합니다.

```bash
# namespaces 유형의 리소스에 대한 삭제 작업 만 허용
kubectl -n db create role role-2 --verb=delete --resource=namespaces

# 새로 생성된 Role을 Pod의 ServiceAccount에 바인딩하기 위해 생성
#  --serviceaccount=<네임스페이스>:<서비스어카운트이름>
kubectl -n db create rolebinding role-2-binding --role=role-2 --serviceaccount=db:service-account-web
```

[참고] [Using RBAC Authorization](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)

---

### 5. log audit

[[Test Lab] auditing-enable-audit-logs](https://killercoda.com/killer-shell-cks/scenario/auditing-enable-audit-logs)

■ 기록할 기본 정책을 편집하고 확장

- `RequestResponse` 수준에서 `영구 볼륨` 변경
- 네임스페이스 `front-apps` 의 `configmaps` 변경 사항 에 대한 `요청` 본문
- `메타데이터` 수준 에서 모든 네임스페이스의 `ConfigMap` 및 `Secret`에 대한 변경 사항
- 또한 `포괄 규칙`을 추가하여 메타데이터 수준에서 다른 `모든 요청을 기록`합니다 .


```bash
vi /etc/kubernetes/logpolicy/sample-policy.yaml
```

sample-policy.yaml

```yaml
  - level: RequestResponse
    resources:
    - group: ""
      resources: ["persistentvolumes"]
​
​  - level: Request
    resources:
    - group: ""
      resources: ["configmaps"]
      namespaces: ["front-apps"]
​
  - level: Metadata
    resources:
    - group: ""
      resources: ["secrets", "configmaps"]
​
  - level: Metadata
    omitStages:
      - "RequestReceived"
```

- [debug-cluster audit](https://kubernetes.io/docs/tasks/debug/debug-cluster/audit/)

​
■ 클러스터에서 감사 로깅을 활성화합니다.

- 로그는 `/var/log/kubernetes/audit-logs.txt` 에 저장됩니다.
- 로그 파일은 `10일` 동안 보관할 수 있습니다.
- 최대 `2개`의 이전 감사 로그 파일 유지
​

```bash
# kube-apiserver.yaml 파일을 편집합니다.
vi /etc/kubernetes/manifests/kube-apiserver.yaml
```

아래 내용으로 수정하거나 추가합니다.

```yaml
- --audit-policy-file=/etc/kubernetes/logpolicy/sample-policy.yaml  # 정책정의파일
- --audit-log-path=/var/log/kubernetes/audit-logs.txt               # 로그저장위치
- --audit-log-maxage=10                                             # 로그보관기간
- --audit-log-maxbackup=2                                           # 로그파일유지

volumeMounts:
- mountPath: /etc/kubernetes/logpolicy/sample-policy.yaml
  name: audit
  readOnly: true
- mountPath: /var/log/kubernetes/
  name: audit-log
  readOnly: false

volumes:
- name: audit
  hostPath:
  path: /etc/kubernetes/logpolicy/sample-policy.yaml
  type: File
- name: audit-log
  hostPath:
  path: /var/log/kubernetes/
  type: DirectoryOrCreate
```
​
■ 서비스 재시작

```bash
systemctl restart kubelet
````

---

### 6. Secret

■  네임스페이스 `istio-system`에서 `db1-test` 라는 기존 비밀의 내용을 가져옵니다.  
사용자 이름 필드를 `/cks/sec/user.txt`라는 파일에 저장 하고 암호 필드를 `/cks/sec/pass.txt` 파일이라는 파일에 저장합니다. 

```bash
kubectl -n istio-system get secrets db1-test -o jsonpath={.data.username} | base64 -d > /cks/sec/user.txt
kubectl -n istio-system get secrets db1-test -o jsonpath={.data.password} | base64 -d > /cks/sec/pass.txt
```
​
■  다음 콘텐츠를 사용하여 `istio-system` 네임 스페이스 에 `db2-test` 라는 새 비밀을 생성 합니다.
 
```bash
kubectl -n istio-system create secret generic db2-test --from-literal username=production-instance --from-literal assword=KvLftKgs4aVH
kubectl -n istio-system get secret
```

■  네임스페이스 `istio-system` 컨테이너 이름 `dev-container` 이미지 `nginx` 볼륨 이름 `secret-volume` 마운트 경로 `/etc/secret`

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secret-pod
  namespace: istio-system
spec:
  containers:
  - name: dev-container
    image: nginx
    volumeMounts:               # secret volumeMounts
    - name: secret-volume
      mountPath: "/etc/secret"
  volumes:                      # secret volumes
  - name: secret-volume
    secret:
      secretName: db2-test
```

---

### 7. Dockefile

■ Dockerfile 파일 수정, 아래 2개를 고친다.

```dockerfile
FROM ubuntu:18.04
USER nobody
```

■ deployment.yaml 파일 수정

- 레이블 체크 
  - app: couchdb
- securityContext 수정
  - `SYS_ADMIN` 필드 제거
  - `privileged`가 `false` 확인

---

### 8. gVisor
runc 라는 기존 런타임 핸들러를 사용하여 untrusted 라는 RuntimeClass를 만듭니다.  
gVisor 에서 실행되도록 네임스페이스 서버 의 모든 Pod를 업데이트합니다.

■ runtimeclass 만들기

- `handler: runsc`를 추가

```yaml
​apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: untrusted
handler: runsc
```

■ 적용하기

- 3개의 deployment를 수정해야한다.
- `runtimeClassName: untrusted`을 추가
- `kubectl rollout status deployment mydeploy`명령을 통해 Pod 교체


```yaml
spec:
  runtimeClassName: untrusted
  containers:
  - image: nginx:1.9
    name: run-test
```

---

### 9. Trivy

[[Test Lab] Scan images using Trivy](https://killercoda.com/killer-shell-cks/scenario/image-vulnerability-scanning-trivy)

Trivy 오픈 소스 컨테이너 스캐너를 사용하여 네임스페이스 banana 이미지에서 치명적인 취약성이 있는 팟(Pod)을 감지하십시오.  
심각도가 높거나 심각한 취약점이 있는 이미지를 찾아 해당 이미지를 사용하는 Pod를 삭제합니다.

■ Pod에 사용된 이미지 조사

```bash
# Pod 이미지 조사
kubectl -n applications get pod -oyaml | grep image:

# trivy 사용
trivy image --severity HIGH,CRITICAL <이미지이름>
trivy -q image -s HIGH,CRITICAL <이미지이름>
```

■ 취약점이 카운트된 Pod를 삭제한다.

---

### 10. AppArmor
클러스터의 작업자 노드 node02에서 /etc/apparmor.d/nginx_apparmor 에 있는 기존 APPArmor 구성 파일을 구현하십시오. /cks/KSSH00401/nginx-deploy.yaml 에 있는 기존 매니페스트 파일을 편집하여 AppArmor 프로필을 적용합니다. 마지막으로 매니페스트 파일이 적용되고 여기에 지정된 포드가 생성됩니다.

​1) APPArmor 구성 파일

```bash
vi /etc/apparmor.d/etc/apparmor.d/nginx_apparmor

#include <tunables/global>
#nginx-profile-3
profile nginx-profile-3 flags=(attach_disconnected) {
  #include <abstractions/base>
  file,
  # Deny all file writes.
  deny /** w,
}
```

2) Apparmor 정책 모듈 실행 및 확인

```bash
apparmor_parser -q /etc/apparmor.d/nginx_apparmor
apparmor_status | grep nginx-profile-3
```

3) Pod에 프로필 적용

```yaml
annotations:
# container.apparmor.security.beta.kubernetes.io/<container_name>: <profile_ref>
  container.apparmor.security.beta.kubernetes.io/podx: localhost/nginx-profile-3
```
- Pod이름이 Podx임..오해마시길...
- [apparmor example](​https://kubernetes.io/docs/tutorials/security/apparmor/#example)

---

### 11. Sysdig & falco
런타임 탐지 도구(Sysdig & falco)를 사용하여 Pod tomcat123 의 단일 컨테이너에서 자주 생성되고 실행되는 비정상적인 프로세스를 탐지합니다

1) containerd의 소켓과 tomcat123 컨테이너 찾기

```bash
# /run/containerd/containerd.sock  정보 확인
crictl info | grep sock
​
# container.name=tomcat123 정보 확인
crictl ps | grep tomcat123
```

- 시험에서는 container id와 pod id는 사실 동일하다.

2) sysdig를 통해 30초 동안 컨테이너를 스캔하고 지정된 파일로 출력

```bash
sysdig -M 30 -p "%evt.time,%user.name,%proc.name" --cri /run/containerd/containerd.sock container.name=tomcat123 >> /opt/KSR00101/incidents/summary

sysdig -M 30 -p "%evt.time,%user.uid,%proc.name" --cri /run/containerd/containerd.sock container.name=tomcat123 >> /opt/KSR00101/incidents/summary
```

- `-M 30` 옵션은 30초 동안 sysdig를 실행하도록 지정합니다.
- `-p "%evt.time,%user.name,%proc.name"` 옵션은 이벤트가 발생한 시간, 사용자 이름, 프로세스이름을 출력할 것을 지정합니다.
- `--cri /run/containerd/containerd.sock` 옵션은 CRI를 사용하고, `/run/containerd/containerd.sock` 소켓 경로를 지정합니다.
- `container.name=tomcat123`는 tomcat123이라는 이름의 컨테이너에서 실행 중인 이벤트만 필터링하도록 지정합니다.

---

### 12. Container Security Context

- 사용자 ID 30000 으로 컨테이너 시작 (사용자 ID를 30000으로 설정)
- 프로세스가 상위 권한 이상의 권한을 얻도록 허용하지 않음(allowPrivilegeEscalation 허용 안 함)  
- 컨테이너의 루트 파일 시스템을 읽기 전용으로 마운트합니다(루트 파일에 대한 읽기 전용 액세스)
​
1) 문제에서 주어진 Pod를 수정하기 위해 Deployment 또는 Pod를 찾아 edit를 한다.
​

```bash
kubectl -n sec-ns edit deployment secdep

# spec 부분에서 아래와 같이 사용자 ID 설정을 한다.

  securityContext:
    runAsUser: 1000

# containers 부분에서 설정한다.(여러개 이면 맞춰서 여러번 수정)

  securityContext:
    allowPrivilegeEscalation: false  # 프로세스가 상위 권한 이상의 권한을 얻도록 허용하지 않음
readOnyRootFilesystem: true      # 루트 파일에 대한 읽기 전용 액세스
```

---

### 13. API Server

인증 및 승인된 REST 요청만 허용되도록 클러스터의 Kubernetes API 서버를 재구성합니다.

1) 인증 모드 Node , RBAC 및 허용 컨트롤러 NodeRestriction 을 사용하십시오 . 

```bash
vi /etc/kubernetes/manifests/kube-apiserver.yaml

# authorization-mode를 Node,RBAC 으로 수정
- --authorization-mode=Node,RBAC

# enalb-admission-plugins를 NodeRestriction 으로 수정
- --enable-admission-plugins=NodeRestriction 

# 서비스 재시작
systemctl daemon-reload
systemctl restart kubelet
```

2) 사용자 system:anonymous 의 ClusterRoleBinding을 삭제하여 정리합니다.

```bash
kubectl get clusterrolebinding system:anonymous
kubectl delete clusterrolebinding system:anonymous
```

---

### 14. TLS

1) kube-apiserver 수정하기

TLS를 통해 kube-apiserver의 보안 구성을 강화합니다.

- TLS 1.3 이상을 제외하고 kube-apiserver 는 다른 버전에서 사용할 수 없습니다.
- 암호 그룹(Cipher suite)은 TLS_AES_128_GCM_SHA256 입니다.


```bash
vi /etc/kubernetes/manifests/kube-apiserver.yaml

    - --tls-cipher-suites=TLS_AES_128_GCM_SHA256
    - --tls-min-version=VersionTLS13
```

https://kubernetes.io/docs/ 에서 `Reference > Component tools > kube-apiserver` 로 이동한다.
tls 키워드로 검색한다. 문서 하단에 `--tls-cipher-suites`와 `--tls-min-version`을 참고하여
`kube-apiserver.yaml`에 추가한다.

2) etcd 수정하기
TLS를 통해 etcd 보안 구성을 강화하려면 다음이 필요합니다.

- 암호 그룹(Cipher suite)은 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 입니다.

```bash
vi /etc/kubernetes/manifests/etcd.yaml

  --cipher-suites TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
```

https://etcd.io/ 에 접속해서 `docs > Operations guide > Transport security model` 페이지로 이동한다.  
`cipher` 키워드로 검색한다. `--cipher-suites` 옵션을 발견하면 추가로 검색하여 어떻게 설정하는지 참고한다.

---

### 15. ImagePolicyWebhook

- 미러링 정책 생성에 필요한 플러그인 활성화
- 제어 구성을 검증하고 암시적 거부로 변경
- 제공된 HTTPS 끝점을 올바르게 가리키도록 구성을 편집합니다.

1) 제어 구성을 검증하고 암시적 거부로 변경

```bash
vi /etc/kubernetes/epconfig/admission_configuration.json
    "defaultAllow": false  # false로 변경
```

2) webhook 서버 주소 추가
```bash
vi /etc/kubernetes/epconfig/kubeconfig.tml
    server: https://image-bouncer-webhook.default.svc:1323/image_policy  # 주소 추가
```

3) kube-apiserver 수정 (enable-admission-plugins, admission-control-config-file)

```bash
vi /etc/kubernetes/manifests/kube-apiserver.yaml

# ImagePolicyWebhook 추가
- --enable-admission-plugins=NodeRestriction,ImagePolicyWebhook

# 설정파일
- --admission-control-config-file=/etc/kubernetes/epconfig/admission_configuration.json

# 볼륨설정 추가
- volumeMounts:
  - mountPath:/etc/kubernetes/epconfig
    name: epconfig
- volumes:
  - name: epconfig
    hostPath:
      path: /etc/kubernetes/epconfig

# 서비스 재시작
systemctl restart kubelet
kubectl -n kube-system get pod
```