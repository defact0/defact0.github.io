---
title: "CKS(Certified Kubernetes Security Specialist) 공부"
date: 2023-05-21
last_modified_at: 2023-05-27
categories:
  - Kubernetes
tags:
  - Certification
tagline: "CKS(Certified Kubernetes Security Specialist) 프로그램은 CKS가 빌드, 배포 및 런타임 중에 컨테이너 기반 애플리케이션 및 Kubernetes 플랫폼을 보호하기 위한 광범위한 모범 사례에 대한 기술, 지식 및 역량을 보유하고 있음을 보증합니다.이 시험에 응시하려면 CKA 인증이 필요합니다."
header:
  overlay_image: /images/overlay_image.jpg
  overlay_filter: 0.5 # same as adding an opacity of 0.5 to a black 
---

## 시험 환경
- 시험은 PSI 전용 프로그램안에서 실행한다.
- 전용 프로그램안에 원격 터미널로 시험환경에 접속하는데 리눅스 GUI환경에서 작업할 수 있다.
- 클립보드는 막혀있다.
- 시험환경에서는 한글지원이 안된다. 한글이 깨진다.
- 북마크는 따로 제공해 준다. 시험 키워드 글자를 누르면 시험환경의 파이어폭스 브라우저에서 페이지로 이동한다.
- 시험 시작하면 먼저 텍스트 문서를 하나 만든다음 시험 문제를 1번 부터 16번 까지 적어두고 문제를 풀었으면 표시를 해 두자! (시험 환경에서는 풀었는지 안풀었는지 구분할 수 없다.)
- 시험 시간이 2시간이지만 시간이 매우 부족하다.

---

### 01. CIS (Center for Internet Security) Kubernetes Benchmark

#### API-Server 수정

```bash
# kube-bench 도구 실행
kube-bench master
```

```bash
# kube-apiserver.yaml 수정
vi /etc/kubernetes/manifests/kube-apiserver.yaml

- --authorization-mode=Node,RBAC # 매개변수를 Node,RBAC으로 수정한다.
- --insecure-bind-address=0.0.0.0 # 해당 줄을 삭제한다.
```

#### kubelet 수정

```bash
# kube-bench 도구 실행
kube-bench node

# kubelet 상태 확인
systemctl status kubelet

# Environment="KUBELET_CONFIG_ARGS=--config= /var/lib/kubelet/config.yaml" 확인
cat /etc/systemd/system/kubelet.service.d/10-kubeadm.conf
```

```bash
# kubelet config.yaml 수정
vi /var/lib/kubelet/config.yaml

authentication:
  anonymous:
    enabled: false # false로 설정
  webhook:
    cacheTTL: 0s
    enabled: true # true로 설정
  x509:
    clientCAFile: /etc/kubernetes/pki/ca.crt
  authorization:
    mode: Webhook # Webhook로 설정
    webhook:
```

```bash
# kubelet 서비스 재시작
systemctl daemon-reload
systemctl restart kubelet.service
```

#### etcd 수정

```bash
# etcd.yaml 수정
vi /etc/kubernetes/manifests/etcd.yaml

​- --client-cert-auth=true  # true로 설정
```

apiserver가 정상적으로 동작하는지 확인한다.

---


### 02. Pod에 ServiceAccount 설정

#### ServiceAccount 생성

```bash
vi qa-sa.yaml

apiVersion: v1
kind: ServiceAccount
metadata:
  name: backend-sa #해당 이름으로 변경
  namespace: qa #namespace 이름
automountServiceAccountToken: false #false는 비밀을 자동으로 마운트하지 않음을 의미합니다.
```
- `automountServiceAccountToken: false` 설정한다.
- 작성한 yaml 파일 저장후 생성한다.

```bash
kubectl -f qa-sa.yaml create
kubectl -n qa get sa
``` 

#### 추가 생성한 ServiceAccount를 적용된 Pod 생성하기

```bash
vim /cks/sa/pod1.yaml

……
metadata:
  name: backend
  namespace: qa #네임스페이스가 올바른지 주의하십시오.
spec:
  serviceAccountName: backend-sa # 이전만 생성한 ServiceAccount 이름 추가
containers:
……
```

- `serviceAccountName: backend-sa` 설정한다.

#### 마지막으로 사용하지 않는 ServiceAccount 삭제한다.

```bash
# sa 리스트 확인
kubectl -n qa get sa

# 사용중인 sa 필터링
kubectl -n qa get pod -o yaml | grep -i serviceAccountName

# 필터링 리스트에 없는 sa 삭제
kubectl -n qa delete sa test01
```

---

### 03. 기본 거부 NetworkPolicy

기본 템플릿 파일이 제공된다.

#### yaml 파일 편집

```bash
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: denypolicy # 이름을 수정할 때 주의하십시오.
  namespace: testing #네임스페이스 추가
spec:
  podSelector: {}
  policyTypes:
  - Ingress #Ingress+Egress인지, Ingress인지 아니면 Egress인지에 대한 질문에 주의
  - Egress # 1.25 시험에서는 모든 egress 트래픽을 거부하는 것만 요구하므로 - Egress 만 쓴다.
```

생성 및 확인

```bash
kubectl -f /cks/net/p1.yaml create
kubectl -n testing describe networkpolicies denypolicy
```

---

### 04. RBAC - RoleBinding

ServiceAccount 역할 바인딩의 해당 관계 보기

```bash
kubectl -n db describe rolebindings

# role-1 권한 편집
kubectl -n db edit role role-1
```

service 유형의 리소스에 대한 가져오기 작업 만 허용

```bash
rules:
- apiGroups:
  - ""
  resources:
  - services
  verbs:
  - get
```

수정된 정책을 확인한다.

```bash
kubectl -n db describe role role-1
```

db 네임스페이스에서 role-2라는 role을 만들고 rolebinding을 통해 service-account-web을 binding한다. 그리고 namespace에 대한 delete 작업만 허용한다.

```bash
kubectl -n db create role role-2 --verb=delete --resource=namespaces
kubectl -n db create rolebinding role-2-binding --role=role-2 --serviceaccount=db:service-account-web
kubectl -n db describe rolebindings
```

---

### 05. Audit log

#### master node log policy

```bash
ssh master01
sudo -i
cp /etc/kubernetes/logpolicy/sample-policy.yaml bak/
vi /etc/kubernetes/logpolicy/sample-policy.yaml
```

```yaml
- level: RequestResponse
  resources:
  - group: ""
    resources: ["presistentvolumes"]
- level: Request
  resources:
  - group: ""
    resources: ["condigmaps"]
    namespace: ["front-apps"]
- level: Metadata
  omitStages:
  - "RequestReceived"    
```

#### master node kube apiserver

```bash
cp /etc/kubernetes/manifests/kube-apiserver.yaml bak/
vi /etc/kubernetes/manifests/kube-apiserver.yaml
```

```yaml
# audit-log
- --audit-policy-file=/etc/kubernetes/logpolicy/sample-policy.yaml
- --audit-log-path=/var/log/kubernetes/audit-logs.txt
- --audit-log-maxage=10
- --audit-log-maxbackup=2

# volumeMounts
volumeMounts:  # 이 필드를 찾아 다음 콘텐츠를 추가합니다.
- mountPath: /etc/kubernetes/logpolicy/sample-policy.yaml
  name: audit
  readOnly: true
- mountPath: /var/log/kubernetes/
  name: audit-log
  readOnly: false
​
# volumes
volumes:
- name: audit
  hostPath:
  path: /etc/kubernetes/logpolicy/sample-policy.yaml
  type: File
- name: audit-log
  hostPath:
  path: /var/log/kubernetes/
  type: DirectoryOrCreate
```

#### master node kubelet service restart

```bash
# kubelet 서비스 재시작
systemctl daemon-reload
systemctl restart kubelet.service
```

---

### 06. Secret

base64 디코딩으로 사용자의 이름과 암호를 지정된 파일에 저장한다.

```bash
kubectl -n istio-system get secrets db1-test -o jsonpath={.data.username} | base64 -d > /cks/sec/user.txt
kubectl -n istio-system get secrets db1-test -o jsonpath={.data.password} | base64 -d > /cks/sec/pass.txt
```

암호에 특수 문자(예: $, \, , = 및 !)가 있는 경우 --from-literal=password='G!Y\ d$zDsb' 와 같이 이스케이프하려면 작은따옴표를 추가해야 합니다.
{: .notice}

```bash
kubectl -n istio-system create secret generic db2-test --fromliteral username=production-instance --from-literal password=KvLftKgs4aVH
kubectl -n istio-system get secret
```

vi k8s-secret.yaml

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secret-pod
  namespace: istio-system
spec:
  containers:
  - name: dev-container
    image: nginx
    volumeMounts: # add
    - name: secret-volume
      mountPath: "/etc/secret"
  volumes: # add
  - name: secret-volume
    secret:
      secretName: db2-test
```

```bash
kubectl -f k8s-secret.yaml create
kubectl -n istio-system get pod
```

---

### 07. Dockerfile

vi /cks/docker/Dockerfile

```Dockerfile
FROM ubuntu:16.04

USER nobody
```

vi /cks/docker/deployment.yaml

```yaml
app: couchdb
가끔 SYS_ADMIN 삭제, 가끔 'privileged': False로 변경
```

---


### 08. gVisor

런타임 클래스 만들기

```bash
vi /cks/gVisor/rc.yaml
```

```yaml
apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: untrusted
handler: runsc
```

- `handler: runsc` 설정


```bash
kubectl -f /cks/gVisor/rc.yaml create
kubectl get RuntimeClass
```

수정해야 할 deployment가 3개 있다.

```bash
kubectl -n server get deployment
kubectl -n server edit deployments busybox-run
kubectl -n server edit deployments nginx-host
kubectl -n server edit deployments run-test
```

아래와 같이 수정한다.

```yaml
spec:
  runtimeClassName: untrusted
  containers:
  - image: nginx:1.9
    imagePullPolicy: IfNotPresent
    name: run-test
```

- `runtimeClassName: untrusted` 설정

---

### 09. NetworkPolicy, pod 제한

네임스페이스 태그 확인

```bash
kubectl get ns --show-labels
kubectl get pod -n dev-team --show-labes

# 만일, 레이블이 없으면 설정을 해야 한다
kubectl label ns qaqa name=qaqa
kubectl label pod products-service environment=testing -n dev-team
```

NetworkPolicy를 생성한다.

```yaml
​apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: pod-restriction
  namespace: dev-team
spec:
  podSelector:
  matchLabels:
    environment: testing
  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector:
      matchLabels:
        name: qaqa
  - from:
    - namespaceSelector: {}
      podSelector:
        matchLabels:
          environment: testing
```

적용한다.

```bash
kubectl apply -f /cks/net/po.yaml
kubectl get networkpolicy -n dev-team
```

---

### 10. Trivy Scanning Mirror Security Vulnerability

1. namespace에서 pod 및 image 확인한다.
2. trivy 명령어로 이미지를 점검한다.
3. 취약점이 발견된 이미지를 사용한 pod를 삭제한다.

```bash
# 이미지 점검
trivy -q image -s HIGH,CRITICAL <pod image>

# pod 삭제(tri1, tri2, tir3)
kubectl -n kamino delete pod tri1 tri2 tir3
```

---

### 11. AppArmor

APPArmor는 worker node에 위치해 있다.

```bash
ssh node02
sudo -i

vi /etc/apparmor.d/nginx_apparmor
```

```c
#include <tunables/global>
#nginx-profile-3 #이 줄이 있는지 확인하고, 있으면 주석 처리
profile nginx-profile-3 flags=(attach_disconnected) {
  #include <abstractions/base>
  file,
  # Deny all file writes.
  deny /** w,
}
```

Apparmor 정책 모듈 실행 및 확인

```bash
apparmor_parser -q /etc/apparmor.d/nginx_apparmor
apparmor_status | grep nginx-profile-3
```

Pod 수정, 기본 터미널의 초기노드에 있다.

```bash
vi /cks/KSSH00401/nginx-deploy.yaml

annotations:
  container.apparmor.security.beta.kubernetes.io/podx: localhost/nginx-profile-3

kubectl -f /cks/KSSH00401/nginx-deploy.yaml create

kubectl get pod
kubetl exec podx -- cat /proc/1/attr/current
kubetl exec podx -- touch /tmp/test
```

- [apparmor example](https://kubernetes.io/docs/tutorials/security/apparmor/#example)

---

### 12. Sysdig & falco

Sysdig는 worker node에 위치해 있다.

```bash
ssh node02
sudo -i

# containerd의 소켓 찾기
crictl info | grep sock

# crictl 명령을 사용하여 컨테이너를 찾습니다.
crictl ps | grep tomcat123
```

```bash
# 30초간 컨테이너 스캔을 시작한다.
sysdig -M 30 -p "%evt.time,%user.uid,%proc.name" --cri /run/containerd/containerd.sock container.name=tomcat123 >> /opt/KSR00101/incidents/summary

# 실행에 문제가 있다면 아래 명령어를 실행한다.
sysdig-probe-loader
```

---

### 13. Container Security Context

```bash
kubectl -n sec-ns edit deployment secdep
```

deployment 수정내용에서 cotainer 마다 아래 내용을 추가한다.

```yaml
securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
```

- 프로세스가 상위 권한 이상의 권한을 얻도록 허용하지 않음(allowPrivilegeEscalation 허용 안 함)
- 컨테이너의 루트 파일 시스템을 읽기 전용으로 마운트합니다(루트 파일에 대한 읽기 전용 액세스).


deployment 수정내용에서 spec에 아래 내용을 추가한다.

```yaml
securityContext:
  runAsUser: 30000
```
- 사용자 ID 30000 으로 컨테이너 시작 (사용자 ID를 30000으로 설정)

---

### 14. API Server

작업할 위치는 master node 이다.

```bash
ssh master01
sudo -i

# kube-apiserver 수정
vi /etc/kubernetes/manifests/kube-apiserver.yaml

- --authorization-mode=Node,RBAC # Node,RBAC 으로 수정
- --enable-admission-plugins=NodeRestriction # NodeRestriction 으로 수정

# 서비스 재시작
systemctl daemon-reload
systemctl restart kubelet
kubectl get pod -A          #클러스터가 정상으로 돌아가려면 몇 분 정도 걸립니다.

# system:anonymous 삭제
kubectl get clusterrolebinding system:anonymous
kubectl delete clusterrolebinding system:anonymous
kubectl get clusterrolebinding system:anonymous
```

---

### 15. TLS security configuration

TLS를 통해 kube-apiserver의 보안 구성을 강화합니다.
- TLS 1.3 이상을 제외하고 kube-apiserver 는 다른 버전에서 사용할 수 없습니다.
- 암호 그룹(Cipher suite)은 TLS_AES_128_GCM_SHA256 입니다.

아래 링크를 통해 --tls-cipher-suites strings 와 --tls-min-version string 부분을 참고한다. [kube-apiserver options](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/#options)
{: .notice}

TLS를 통해 etcd 보안 구성을 강화하려면 다음이 필요합니다.
- 암호 그룹(Cipher suite)은 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 입니다.

​메뉴 위치는 Reference > Component tools > kube-apiserver 이다.
https://etcd.io/docs/v3.4/op-guide/security/ 에서
{: .notice}

```bash
$ etcd \
  --cert-file ./server.crt \
  --key-file ./server.key \
  --trusted-ca-file ./ca.crt \
  --cipher-suites TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
```
`--cipher-suites` 부분을 참고한다.

```bash
1) 클러스터를 스위치 한다.
kubectl config user-context KSRS00501

2) 마스터 노드로 SSH 접속을 한다.
ssh master01
sudo -i

3) kube-apiserver를 수정하기 이전에 파일을 백업해 두는 것이 좋습니다.
mkdir bakyaml
cp /etc/kubernetes/manifests/kube-apiserver.yaml bakyaml/
vim /etc/kubernetes/manifests/kube-apiserver.yaml
​
4) 문제에서 요구한 kube-apiserver의 보안 구성을 강화합니다.
    - --tls-cipher-suites=TLS_AES_128_GCM_SHA256
    - --tls-min-version=VersionTLS13

5) 3분을 기다린 다음 kube-apiserver를 확인하여 정책이 클러스터에 적용된 후 실행 중인지 확인합니다.
kubectl -n kube-system get pod

6) etcd 수정
cp /etc/kubernetes/manifests/etcd.yaml bakyaml/
vim /etc/kubernetes/manifests/etcd.yaml

7) 문제에서 요구한 etcd 보안 구성을 강화 구성을 설정합니다.
    - --cipher-suites=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256

8) 수정완료 후 3분간 대기해야 합니다. 특히 etcd와 kube-apiserver의 pod를 확인하여 정상인지 체크해야 합니다.
kubectl get pod -A
kubectl -n kube-system get pod
```

---

### 16. ImagePolicyWebhook Container image scanning

```bash
# 1) 마스터에서 원격으로 전환하고 루트로 전환
ssh master01
sudo -i

# 2) Admission_configuration.json을 편집하고(제목이 이 디렉터리를 제공함) defaultAllow를 false로 수정합니다.
vi /etc/kubernetes/epconfig/admission_configuration.json

    "denyTTL": 50,
    "retryBackoff": 500,
    "defaultAllow": false  # 참을 거짓으로 변경

# 3) /etc/kubernetes/epconfig/kubeconfig.yml 편집, webhook 서버 주소 추가:
# 작업 전에 구성 파일을 먼저 백업

​cp /etc/kubernetes/epconfig/kubeconfig.yml bakyaml/
vi /etc/kubernetes/epconfig/kubeconfig.yml

# 다음 내용 수정

    certificate-authority: /etc/kubernetes/epconfig/server.crt
    server: https://image-bouncer-webhook.default.svc:1323/image_policy #웹훅 서버 주소 추가
  name: bouncer_webhook

# 4) kube-apiserver.yaml을 편집하고 공식 웹사이트에서 ImagePolicyWebhook의 구성 정보를 인용합니다. 작업 전에 구성 파일을 백업합니다.

cp /etc/kubernetes/manifests/kube-apiserver.yaml bakyaml/
vi /etc/kubernetes/manifests/kube-apiserver.yaml

# ​-command: 아래에 다음 내용을 추가합니다. 
# 공백 정렬에 주의하세요(끝에 넣는 것은 권장하지 않으며 권장 위치는 아래 스크린샷에 표시됨).
​
- --enable-admission-plugins=NodeRestriction,ImagePolicyWebhook
- --admission-control-config-file=/etc/kubernetes/epconfig/admission_configuration.json


# kube-apiserver.yaml에 volumeMount 추가

volumeMounts:
- mountPath: /etc/kubernetes/epconfig
name: epconfig
readOnly: true

# kube-apiserver.yaml에 볼륨 추가

volumes: 
- name: epconfig
hostPath:
path: /etc/kubernetes/epconfig
type: DirectoryOrCreate

# 5) 재부팅 및 클러스터 확인
systemctl restart kubelet
kubectl -n kube-system get pod

​
# 6) 취약한 리소스 /cks/img/web1.yaml 배포를 시도하여 구성이 유효한지 테스트합니다 .
# 포드를 생성할 수 없습니다. 성공을 나타내는 다음 오류가 보고됩니다.
# 시뮬레이션 환경의 image_policy 전략은 이미지 태그가 최신이며 생성이 허용되지 않기 때문입니다.
​
kubectl apply -f /cks/img/web1.yaml
```